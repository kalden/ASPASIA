package modelCreation;

import java.io.File;
import java.util.ArrayList;
import java.util.Map;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import xmlFileUtilities.XMLFileUtilities;

/**
 * \brief Creates Non-SBML Model Files (Part of Development of Version 2)
 * 
 * Used by the Create_[Analysis]_Classes to write the simulation parameter files
 * for each value set generated by spartan, in cases where the model is not in
 * SBML
 * 
 * @author Kieran Alden, York Computational Immunology Lab
 * @version 1.0
 * @since February 2015
 *
 */
public class WriteParameterFile
{
    /**
     * Count of the file produced - used in file numbering
     */
    public static int count = 1;

    /**
     * Determines if a parameter is of interest to the analysis. If so, returns
     * true and the value is assigned to that in the spartan CSV file. If not,
     * returns false and the parameter is assigned its calibrated value
     * 
     * @param parameters Arraylist of parameter names of interest to the
     *            analysis
     * @param paramToFind The name of the parameter currently being written to
     *            the XML file - the parameter to check
     * @return True if the parameter is of interest to the analysis, false if
     *         not
     */
    public static String checkArrayList(ArrayList<String> parameters, String paramToFind)
    {
	String found = "null";

	for (int param = 0; param < parameters.size(); param++)
	{
	    String paramInArray = parameters.get(param);

	    if (paramInArray.equals(paramToFind))
	    {
		found = XMLFileUtilities.parameterType.get(param);
	    }
	}

	return found;

    }

    /**
     * Parse each parameter value set created by spartan, producing a simulation
     * parameter file for each. Parameters not involved in the analysis remain
     * at their calibrated value, with parameters of interest taking their value
     * created in the spartan sample
     * 
     * @param calibratedParamFilePath Full path to the simulation parameter file
     *            at calibrated values
     * @param parameterValLine A line from the spartan parameter value file
     * @param params The names of the parameters of interest
     * @param types The data type of each parameter
     * @param outputFolder The full path to the output folder where these
     *            parameter files are stored
     * @param paramFileNum The number of the parameter file (i.e. the sample
     *            number)
     * @param analysis The type of spartan analysis being performed.
     */
    public static void writeSimParameterFiles(String calibratedParamFilePath,
	    Map<String, Double> parameterValMap, ArrayList<String> params, ArrayList<String> types,
	    String outputFolder, int paramFileNum, String analysis)
    {

	// String sampledValue = "0";

	try
	{
	    // Firstly, set up a new XML file, that will become the parameter
	    // file
	    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
	    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
	    Document doc;
	    doc = docBuilder.parse(new File(calibratedParamFilePath));

	    // normalize text representation of the document
	    doc.getDocumentElement().normalize();

	    // For robustness analysis, we append the name of the parameter file
	    // with the value of one parameter. This holds the value
	    // String paramOfIntValue = "";

	    // Write the required root elements
	    Document docWriting = docBuilder.newDocument();
	    Element rootElement = docWriting.createElement(doc.getDocumentElement().getNodeName());
	    docWriting.appendChild(rootElement);
	    count = count + 1;

	    // The parameter values will be split by commas, so a string
	    // tokenizer can be used to break these apart
	    // StringTokenizer st = new StringTokenizer(parameterValLine, ",");

	    // Get the Parameter Group Tags
	    NodeList paramGroups = doc.getDocumentElement().getChildNodes();

	    // Now go through each group in turn (if XML file is split into
	    // groups, that is. If not, will just go through
	    // all tags)
	    for (int j = 0; j < paramGroups.getLength(); j++)
	    {
		if (!paramGroups.item(j).getNodeName().equals("#text"))
		{
		    // Write the tag to the new file
		    Element staff = docWriting.createElement(paramGroups.item(j).getNodeName());
		    // Now determine if the tag has attributes, and if so copy
		    // these to the new parameter file
		    if (paramGroups.item(j).hasAttributes())
		    {
			NamedNodeMap attrs = paramGroups.item(j).getAttributes();
			for (int i = 0; i < attrs.getLength(); i++)
			{
			    staff.setAttribute(attrs.item(i).getNodeName(), attrs.item(i)
				    .getNodeValue());
			}
		    }

		    rootElement.appendChild(staff);

		    // Get the nodes for this child - these will be the
		    // parameters in each group
		    Node n = paramGroups.item(j);
		    NodeList groupVars = n.getChildNodes();

		    // Now go through the tags in this group in turn
		    for (int k = 0; k < groupVars.getLength(); k++)
		    {

			if (!groupVars.item(k).getNodeName().equals("#text"))
			{
			    // Write the tag to the new file

			    Element paramName = docWriting.createElement(groupVars.item(k)
				    .getNodeName());
			    staff.appendChild(paramName);

			    // Now determine if this is a parameter being
			    // altered. If not, the calibrated value is put in
			    // the
			    // new file. If it is, the parameter is recovered
			    // from the spartan CSV file
			    String arrayCheckResult = checkArrayList(params, groupVars.item(k)
				    .getNodeName());

			    if (arrayCheckResult.equals("null"))
			    {
				// Write the calibrated/baseline value of the
				// parameter
				paramName.appendChild(docWriting.createTextNode(groupVars.item(k)
				        .getTextContent()));
			    }
			    else
			    {
				// BODGE JUST FOR SIMONS LEISH WORK WHERE TWO
				// PARAMETERS OF THE SAME NAME
				// USUALLY THIS SHOULD JUST BE NEXTTOKEN
				Double sampledValue = parameterValMap.get(groupVars.item(k)
				        .getNodeName());

				// Recover the value from the csv and place in
				// the file
				// The checker will return the type of the
				// parameter (double or int), so we can round if
				// need be
				if (arrayCheckResult.equals("double"))
				{
				    paramName.appendChild(docWriting.createTextNode(Double
					    .toString(sampledValue)));
				}
				else if (arrayCheckResult.equals("int"))
				{
				    paramName.appendChild(docWriting.createTextNode(Integer
					    .toString((int) Math.round((sampledValue)))));
				}

			    }
			}
		    }

		}
	    }
	    // Now write out the parameter file
	    TransformerFactory transformerFactory = TransformerFactory.newInstance();
	    Transformer transformer = transformerFactory.newTransformer();
	    transformerFactory.setAttribute("indent-number", 2);
	    transformer.setOutputProperty(OutputKeys.INDENT, "yes");

	    docWriting.normalizeDocument();
	    DOMSource source = new DOMSource(docWriting);
	    String paramFileName;

	    // if(analysis.length()==0)
	    paramFileName = outputFolder + "/paramFile_" + (paramFileNum + 1) + ".xml";
	    // else
	    // paramFileName =
	    // outputFolder+"/"+analysis+"_"+paramOfIntValue+".xml";

	    StreamResult result = new StreamResult(new File(paramFileName));
	    transformer.transform(source, result);
	}
	catch (Exception e)
	{
	    e.printStackTrace();
	}
    }

}
